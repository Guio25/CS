-- -*- haskell -*- File generated by the BNF Converter (bnfc 2.9.5).

-- Parser definition for use with Happy
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
{-# LANGUAGE PatternSynonyms #-}

module ParString
  ( happyError
  , myLexer
  , pE
  ) where

import Prelude

import AbsDef
import Lex
import Utils

}

%name pE E
-- no lexer declaration
%monad { Err } { (>>=) } { return }
%tokentype {Token}
%token
  '('      { PT _ (TS _ 1) }
  ')'      { PT _ (TS _ 2) }
  '*'      { PT _ (TS _ 3) }
  '+'      { PT _ (TS _ 4) }
  L_integ  { PT _ (TI $$)  }
  L_quoted { PT _ (TL $$)  }

%%

Integer :: { Int }
Integer  : L_integ  { (read $1) :: Int }

String  :: { String }
String   : L_quoted { $1 }

E :: { Tree Int String }
E : E1 { $1 } | E2 { $1 }

E1 :: { Tree Int String }
E1 : E2 '+' ListE2 { Chain (flatCons $1 $3) }

ListE2 :: { [Tree Int String] }
ListE2 : E2 { flatCons $1 [] } | E2 '+' ListE2 { flatCons $1 $3 }

E2 :: { Tree Int String }
E2 : '(' E2 ')' { $2 } | E3 { $1 }

E3 :: { Tree Int String }
E3
  : I '*' E4 { Repeat $1 $3 }
  | E4 '*' I { Repeat $3 $1 }
  | E4 { $1 }

E4 :: { Tree Int String }
E4 : '(' E1 ')' { $2 } | '(' E4 ')' { $2 } | E5 { $1 }

E5 :: { Tree Int String }
E5 : String { Leaf $1 }

I :: { Int }
I : Integer { $1 }

{

type Err = Either String

happyError :: [Token] -> Err a
happyError ts = Left $
  "syntax error at " ++ tokenPos ts ++
  case ts of
    []      -> []
    [Err _] -> " due to lexer error"
    t:_     -> " before `" ++ (prToken t) ++ "'"

myLexer :: String -> [Token]
myLexer = tokens

}

